; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\lcd_func.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\lcd_func.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\include -I.\RTE\_ADC2TEXTLCD -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__UVISION_VERSION=524 -D_RTE_ -DSTM32F10X_HD --omf_browse=.\obj\lcd_func.crf ..\source\lcd_func.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delay PROC
;;;56     /*----------------------------------*/
;;;57     void delay(int d) //短暫副程式 
000000  2100              MOVS     r1,#0
;;;58     {
;;;59        int i, j;
;;;60         for(i = 0; i < d; i++)
000002  e005              B        |L1.16|
                  |L1.4|
;;;61            for(j = 0; j < 200; j++)  ;
000004  2200              MOVS     r2,#0
000006  e000              B        |L1.10|
                  |L1.8|
000008  1c52              ADDS     r2,r2,#1
                  |L1.10|
00000a  2ac8              CMP      r2,#0xc8
00000c  dbfc              BLT      |L1.8|
00000e  1c49              ADDS     r1,r1,#1              ;60
                  |L1.16|
000010  4281              CMP      r1,r0                 ;60
000012  dbf7              BLT      |L1.4|
;;;62     }
000014  4770              BX       lr
;;;63     
                          ENDP

                  write_com PROC
;;;70     
;;;71     void write_com(unsigned char c)/* 寫入指令暫存器 */
000016  b510              PUSH     {r4,lr}
;;;72     {
000018  4604              MOV      r4,r0
;;;73         //GPIO_Write(GPIOC,c);
;;;74         //GPIO_ResetBits(GPIOC,rs);
;;;75         //en1();  
;;;76     
;;;77         GPIO_Write(GPIOC, c);
00001a  4621              MOV      r1,r4
00001c  489f              LDR      r0,|L1.668|
00001e  f7fffffe          BL       GPIO_Write
;;;78         GPIO_ResetBits(GPIOC, rs);
000022  f44f7100          MOV      r1,#0x200
000026  489d              LDR      r0,|L1.668|
000028  f7fffffe          BL       GPIO_ResetBits
;;;79         GPIO_ResetBits(GPIOC, rw);
00002c  f44f6180          MOV      r1,#0x400
000030  489a              LDR      r0,|L1.668|
000032  f7fffffe          BL       GPIO_ResetBits
;;;80     
;;;81         
;;;82         GPIO_ResetBits(GPIOC, en);        
000036  f44f7180          MOV      r1,#0x100
00003a  4898              LDR      r0,|L1.668|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;83         delay(1);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       delay
;;;84         // send a pulse to enable    
;;;85     
;;;86         GPIO_SetBits(GPIOC, en);
000046  f44f7180          MOV      r1,#0x100
00004a  4894              LDR      r0,|L1.668|
00004c  f7fffffe          BL       GPIO_SetBits
;;;87         delay(1);
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       delay
;;;88         GPIO_ResetBits(GPIOC, en);  
000056  f44f7180          MOV      r1,#0x100
00005a  4890              LDR      r0,|L1.668|
00005c  f7fffffe          BL       GPIO_ResetBits
;;;89         delay(1);
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       delay
;;;90         delay(10);  
000066  200a              MOVS     r0,#0xa
000068  f7fffffe          BL       delay
;;;91     
;;;92     }
00006c  bd10              POP      {r4,pc}
;;;93     
                          ENDP

                  init_lcd PROC
;;;13     /* Private functions ---------------------------------------------------------*/
;;;14     void init_lcd(void) /* LCD 8 bit 存取介面初始化 */
00006e  b510              PUSH     {r4,lr}
;;;15     {
;;;16     
;;;17         //GPIO_ResetBits(GPIOC, en);       /* EN 信號低電位 */
;;;18         //write_com(0x38);  /* 8 bit I/O，雙列顯示      */
;;;19         //write_com(0x0e);  /* 游標出現，不閃爍         */
;;;20         //write_com(0x06);  /* 每次向右移，顯示幕不移動 */
;;;21         //write_com(0x01);  /* 清除 LCD 顯示幕          */
;;;22         //write_com(0x80);
;;;23     
;;;24         delay(100);
000070  2064              MOVS     r0,#0x64
000072  f7fffffe          BL       delay
;;;25         // initiatize lcd after a short pause
;;;26         // needed by the LCDs controller
;;;27         write_com(init1);  
000076  2038              MOVS     r0,#0x38
000078  f7fffffe          BL       write_com
;;;28                              
;;;29         delay(64);                      
00007c  2040              MOVS     r0,#0x40
00007e  f7fffffe          BL       delay
;;;30         write_com(init1);  
000082  2038              MOVS     r0,#0x38
000084  f7fffffe          BL       write_com
;;;31                              
;;;32         delay(50);                      
000088  2032              MOVS     r0,#0x32
00008a  f7fffffe          BL       delay
;;;33         write_com(init1);  
00008e  2038              MOVS     r0,#0x38
000090  f7fffffe          BL       write_com
;;;34      
;;;35         delay(50);                     
000094  2032              MOVS     r0,#0x32
000096  f7fffffe          BL       delay
;;;36      
;;;37         write_com(init2);  // display control:
00009a  200e              MOVS     r0,#0xe
00009c  f7fffffe          BL       write_com
;;;38                              // turn display on, cursor on, no blinking
;;;39         delay(20);                      
0000a0  2014              MOVS     r0,#0x14
0000a2  f7fffffe          BL       delay
;;;40         write_com(init3);  // entry mode set: 06
0000a6  2006              MOVS     r0,#6
0000a8  f7fffffe          BL       write_com
;;;41                              // increment automatically, display shift, right shift
;;;42         delay(20);                      
0000ac  2014              MOVS     r0,#0x14
0000ae  f7fffffe          BL       delay
;;;43                            
;;;44         write_com(clr);  // clear display, set cursor position to zero  
0000b2  2001              MOVS     r0,#1
0000b4  f7fffffe          BL       write_com
;;;45         delay(100);                      
0000b8  2064              MOVS     r0,#0x64
0000ba  f7fffffe          BL       delay
;;;46         write_com(init4);
0000be  2080              MOVS     r0,#0x80
0000c0  f7fffffe          BL       write_com
;;;47                             
;;;48         delay(20);
0000c4  2014              MOVS     r0,#0x14
0000c6  f7fffffe          BL       delay
;;;49     
;;;50     
;;;51     }
0000ca  bd10              POP      {r4,pc}
;;;52     
                          ENDP

                  en1 PROC
;;;64     /*--------------------*/
;;;65     void en1(void) /* LCD 致能控制信號 */
0000cc  b510              PUSH     {r4,lr}
;;;66     {    
;;;67           GPIO_SetBits(GPIOC, en); delay(1);
0000ce  f44f7180          MOV      r1,#0x100
0000d2  4872              LDR      r0,|L1.668|
0000d4  f7fffffe          BL       GPIO_SetBits
0000d8  2001              MOVS     r0,#1
0000da  f7fffffe          BL       delay
;;;68           GPIO_ResetBits(GPIOC,en);
0000de  f44f7180          MOV      r1,#0x100
0000e2  486e              LDR      r0,|L1.668|
0000e4  f7fffffe          BL       GPIO_ResetBits
;;;69     }
0000e8  bd10              POP      {r4,pc}
;;;70     
                          ENDP

                  write_data PROC
;;;94     /*-----------------------------*/
;;;95     void write_data(unsigned char c)/* 寫入資料暫存器 */
0000ea  b510              PUSH     {r4,lr}
;;;96     {
0000ec  4604              MOV      r4,r0
;;;97         //GPIO_Write(GPIOC,c);
;;;98         //GPIO_SetBits(GPIOC,rs);
;;;99         //en1();
;;;100    
;;;101    
;;;102        GPIO_Write(GPIOC, c);    
0000ee  4621              MOV      r1,r4
0000f0  486a              LDR      r0,|L1.668|
0000f2  f7fffffe          BL       GPIO_Write
;;;103        GPIO_SetBits(GPIOC, rs);
0000f6  f44f7100          MOV      r1,#0x200
0000fa  4868              LDR      r0,|L1.668|
0000fc  f7fffffe          BL       GPIO_SetBits
;;;104        GPIO_ResetBits(GPIOC, rw);   
000100  f44f6180          MOV      r1,#0x400
000104  4865              LDR      r0,|L1.668|
000106  f7fffffe          BL       GPIO_ResetBits
;;;105        
;;;106        GPIO_ResetBits(GPIOC, en);       
00010a  f44f7180          MOV      r1,#0x100
00010e  4863              LDR      r0,|L1.668|
000110  f7fffffe          BL       GPIO_ResetBits
;;;107        delay(1);
000114  2001              MOVS     r0,#1
000116  f7fffffe          BL       delay
;;;108        // send a pulse to enable 
;;;109    
;;;110    
;;;111        GPIO_ResetBits(GPIOC, en);        
00011a  f44f7180          MOV      r1,#0x100
00011e  485f              LDR      r0,|L1.668|
000120  f7fffffe          BL       GPIO_ResetBits
;;;112        delay(1);
000124  2001              MOVS     r0,#1
000126  f7fffffe          BL       delay
;;;113        // send a pulse to enable    
;;;114    
;;;115        GPIO_SetBits(GPIOC, en);
00012a  f44f7180          MOV      r1,#0x100
00012e  485b              LDR      r0,|L1.668|
000130  f7fffffe          BL       GPIO_SetBits
;;;116        delay(1);
000134  2001              MOVS     r0,#1
000136  f7fffffe          BL       delay
;;;117        GPIO_ResetBits(GPIOC, en);  
00013a  f44f7180          MOV      r1,#0x100
00013e  4857              LDR      r0,|L1.668|
000140  f7fffffe          BL       GPIO_ResetBits
;;;118        delay(1);
000144  2001              MOVS     r0,#1
000146  f7fffffe          BL       delay
;;;119    
;;;120    }
00014a  bd10              POP      {r4,pc}
;;;121    
                          ENDP

                  print PROC
;;;124    /*在 LCD 的第一行或第二行印出字元 */
;;;125    void print(char line, char *str)
00014c  b570              PUSH     {r4-r6,lr}
;;;126    {	   
00014e  4606              MOV      r6,r0
000150  460d              MOV      r5,r1
;;;127        unsigned char i ;
;;;128        if(line == 1) /* 先將某行清為空白 */
000152  2e01              CMP      r6,#1
000154  d10f              BNE      |L1.374|
;;;129        {
;;;130            write_com(0x80); /* 設定 LCD 的第一行位址 */
000156  2080              MOVS     r0,#0x80
000158  f7fffffe          BL       write_com
;;;131            for(i = 0; i < 16; i++) write_data(' ');
00015c  2400              MOVS     r4,#0
00015e  e004              B        |L1.362|
                  |L1.352|
000160  2020              MOVS     r0,#0x20
000162  f7fffffe          BL       write_data
000166  1c60              ADDS     r0,r4,#1
000168  b2c4              UXTB     r4,r0
                  |L1.362|
00016a  2c10              CMP      r4,#0x10
00016c  dbf8              BLT      |L1.352|
;;;132            write_com(0x80);
00016e  2080              MOVS     r0,#0x80
000170  f7fffffe          BL       write_com
000174  e00e              B        |L1.404|
                  |L1.374|
;;;133        }
;;;134        else
;;;135        {
;;;136            write_com(0xc0);/* 設定 LCD 的第二行位址 */
000176  20c0              MOVS     r0,#0xc0
000178  f7fffffe          BL       write_com
;;;137            for(i = 0; i < 16; i++) write_data(' ');
00017c  2400              MOVS     r4,#0
00017e  e004              B        |L1.394|
                  |L1.384|
000180  2020              MOVS     r0,#0x20
000182  f7fffffe          BL       write_data
000186  1c60              ADDS     r0,r4,#1
000188  b2c4              UXTB     r4,r0
                  |L1.394|
00018a  2c10              CMP      r4,#0x10
00018c  dbf8              BLT      |L1.384|
;;;138            write_com(0xc0);
00018e  20c0              MOVS     r0,#0xc0
000190  f7fffffe          BL       write_com
                  |L1.404|
;;;139       }
;;;140       /* 寫入字元資料 */
;;;141        do{ write_data(*str++); }
000194  bf00              NOP      
                  |L1.406|
000196  f8150b01          LDRB     r0,[r5],#1
00019a  f7fffffe          BL       write_data
;;;142        while(*str!='\0');
00019e  7828              LDRB     r0,[r5,#0]
0001a0  2800              CMP      r0,#0
0001a2  d1f8              BNE      |L1.406|
;;;143    }
0001a4  bd70              POP      {r4-r6,pc}
;;;144    
                          ENDP

                  prline1 PROC
;;;146      /*---------------*/
;;;147    void prline1(char x, char w) /* 在 LCD第一行特定位置顯示字元 */
0001a6  b570              PUSH     {r4-r6,lr}
;;;148    {
0001a8  4604              MOV      r4,r0
0001aa  460d              MOV      r5,r1
;;;149        write_com(0x80 + x);/* 設定 LCD 的第一行某一位址 */
0001ac  f1040180          ADD      r1,r4,#0x80
0001b0  b2c8              UXTB     r0,r1
0001b2  f7fffffe          BL       write_com
;;;150        write_data(w);    /* 寫入資料 */
0001b6  4628              MOV      r0,r5
0001b8  f7fffffe          BL       write_data
;;;151    }
0001bc  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

                  prline2 PROC
;;;153      /*--------------------*/
;;;154    void prline2(char x, char w) /* 在 LCD第二行特定位置顯示字元 */
0001be  b570              PUSH     {r4-r6,lr}
;;;155    {
0001c0  4604              MOV      r4,r0
0001c2  460d              MOV      r5,r1
;;;156        write_com(0xc0 + x);/* 設定 LCD 的第二行某一位址 */
0001c4  f10401c0          ADD      r1,r4,#0xc0
0001c8  b2c8              UXTB     r0,r1
0001ca  f7fffffe          BL       write_com
;;;157        write_data(w);      /* 寫入資料 */
0001ce  4628              MOV      r0,r5
0001d0  f7fffffe          BL       write_data
;;;158    }
0001d4  bd70              POP      {r4-r6,pc}
;;;159    
                          ENDP

                  clear PROC
;;;161    
;;;162    void clear(void)
0001d6  b510              PUSH     {r4,lr}
;;;163    {
;;;164        write_com(clr); //clear screen 
0001d8  2001              MOVS     r0,#1
0001da  f7fffffe          BL       write_com
;;;165    }
0001de  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  home PROC
;;;167    
;;;168    void home(void)
0001e0  b510              PUSH     {r4,lr}
;;;169    {
;;;170        write_com(hm);  // set cursor position to zero
0001e2  2002              MOVS     r0,#2
0001e4  f7fffffe          BL       write_com
;;;171    }
0001e8  bd10              POP      {r4,pc}
;;;172    
                          ENDP

                  setCursor PROC
;;;173    void setCursor(char index)
0001ea  b570              PUSH     {r4-r6,lr}
;;;174    {
0001ec  4604              MOV      r4,r0
;;;175        char cmd;
;;;176        if(index < 16) cmd = 0x80 + index;
0001ee  2c10              CMP      r4,#0x10
0001f0  da03              BGE      |L1.506|
0001f2  f1040080          ADD      r0,r4,#0x80
0001f6  b2c5              UXTB     r5,r0
0001f8  e002              B        |L1.512|
                  |L1.506|
;;;177        else           cmd = 0xc0 + index - 16;
0001fa  f10400b0          ADD      r0,r4,#0xb0
0001fe  b2c5              UXTB     r5,r0
                  |L1.512|
;;;178        
;;;179        write_com(cmd);
000200  4628              MOV      r0,r5
000202  f7fffffe          BL       write_com
;;;180    }
000206  bd70              POP      {r4-r6,pc}
;;;181    
                          ENDP

                  shiftDisplayLeft PROC
;;;182    void shiftDisplayLeft(void)
000208  b510              PUSH     {r4,lr}
;;;183    { 
;;;184        write_com(left);
00020a  2018              MOVS     r0,#0x18
00020c  f7fffffe          BL       write_com
;;;185    }
000210  bd10              POP      {r4,pc}
;;;186    
                          ENDP

                  shiftDisplayRight PROC
;;;187    void shiftDisplayRight(void)
000212  b510              PUSH     {r4,lr}
;;;188    {
;;;189        write_com(right);
000214  201c              MOVS     r0,#0x1c
000216  f7fffffe          BL       write_com
;;;190    }
00021a  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  tohex PROC
;;;209    /*-------------------------*/
;;;210    char tohex(unsigned char value)
00021c  4601              MOV      r1,r0
;;;211    {
;;;212        if(value > 9)
00021e  2909              CMP      r1,#9
000220  dd16              BLE      |L1.592|
;;;213        {
;;;214            switch(value)
000222  f1a1000a          SUB      r0,r1,#0xa
000226  2806              CMP      r0,#6
000228  d210              BCS      |L1.588|
00022a  e8dff000          TBB      [pc,r0]
00022e  0305              DCB      0x03,0x05
000230  07090b0d          DCB      0x07,0x09,0x0b,0x0d
;;;215            {
;;;216    	        case 10: return('a');
000234  2061              MOVS     r0,#0x61
                  |L1.566|
;;;217                case 11: return('b');
;;;218                case 12: return('c');
;;;219                case 13: return('d');
;;;220                case 14: return('e');
;;;221                case 15: return('f');
;;;222                default: return('X');
;;;223            }
;;;224        }
;;;225        else
;;;226        {
;;;227            return(value + 0x30);
;;;228        }
;;;229    }
000236  4770              BX       lr
000238  2062              MOVS     r0,#0x62              ;217
00023a  e7fc              B        |L1.566|
00023c  2063              MOVS     r0,#0x63              ;218
00023e  e7fa              B        |L1.566|
000240  2064              MOVS     r0,#0x64              ;219
000242  e7f8              B        |L1.566|
000244  2065              MOVS     r0,#0x65              ;220
000246  e7f6              B        |L1.566|
000248  2066              MOVS     r0,#0x66              ;221
00024a  e7f4              B        |L1.566|
                  |L1.588|
00024c  2058              MOVS     r0,#0x58              ;222
00024e  e7f2              B        |L1.566|
                  |L1.592|
000250  f1010030          ADD      r0,r1,#0x30           ;227
000254  b2c0              UXTB     r0,r0                 ;227
000256  e7ee              B        |L1.566|
;;;230    
                          ENDP

                  pf4h PROC
;;;195    /*-------------------------*/
;;;196    void pf4h(unsigned int value)
000258  b51c              PUSH     {r2-r4,lr}
;;;197    {
00025a  4604              MOV      r4,r0
;;;198        char buf[5];
;;;199    
;;;200        buf[0] = tohex((value&0xf000)>>12);
00025c  f3c43003          UBFX     r0,r4,#12,#4
000260  f7fffffe          BL       tohex
000264  f88d0000          STRB     r0,[sp,#0]
;;;201        buf[1] = tohex((value&0x0f00)>>8);
000268  f3c42003          UBFX     r0,r4,#8,#4
00026c  f7fffffe          BL       tohex
000270  f88d0001          STRB     r0,[sp,#1]
;;;202        buf[2] = tohex((value&0x00f0)>>4);
000274  f3c41003          UBFX     r0,r4,#4,#4
000278  f7fffffe          BL       tohex
00027c  f88d0002          STRB     r0,[sp,#2]
;;;203        buf[3] = tohex(value&0x000f);
000280  f004000f          AND      r0,r4,#0xf
000284  f7fffffe          BL       tohex
000288  f88d0003          STRB     r0,[sp,#3]
;;;204        buf[4] = 0;
00028c  2000              MOVS     r0,#0
00028e  f88d0004          STRB     r0,[sp,#4]
;;;205    
;;;206        print(1, buf);
000292  4669              MOV      r1,sp
000294  2001              MOVS     r0,#1
000296  f7fffffe          BL       print
;;;207    }
00029a  bd1c              POP      {r2-r4,pc}
;;;208    
                          ENDP

                  |L1.668|
                          DCD      0x40011000
